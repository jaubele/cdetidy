% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_schema_sources.R
\name{filter_schema_sources}
\alias{filter_schema_sources}
\title{Filter a schema log for a specific data source (with optional universal tables)}
\usage{
filter_schema_sources(schema_df, data_source = NULL, include_universal = TRUE)
}
\arguments{
\item{schema_df}{A data frame representing the full schema log, including columns \code{data_source}, \code{dimension_type}, and \code{table_name}.}

\item{data_source}{A string or character vector specifying one or more of \code{"assessment"}, \code{"cde"}, or \code{"dashboard"}. Required.}

\item{include_universal}{Logical. If \code{TRUE}, also includes rows where \code{dimension_type == "universal"}. Default is \code{TRUE}.}
}
\value{
A filtered data frame containing only schema rows matching the specified data source(s),
plus universal tables if \code{include_universal = TRUE}.
}
\description{
Filters a schema metadata table (typically from \code{primary_sql_schema_log.csv}) to include
only rows that match a specified \code{data_source}, optionally including "universal" dimensions.
}
\details{
\itemize{
\item The function normalizes \code{data_source} labels to match the schema log.
\item It will error if no matching rows are found or if an invalid \code{data_source} is provided.
\item Useful for generating SQL, inserts, or table builds scoped to a single source system.
}
}
\examples{
\dontrun{
schema_log <- readr::read_csv("primary_sql_schema_log.csv")
filtered <- filter_schema_sources(schema_log, data_source = "assessment")
}

}
