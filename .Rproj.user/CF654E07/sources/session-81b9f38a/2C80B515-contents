#' Load, standardize ID codes, compare schemas, and optionally join files
#'
#' Searches `folder` for files whose names match `keywords`, reads them with
#' `readr::read_csv()`, **standardizes ID code columns**, normalizes text to
#' UTF-8, compares column sets across files, and (optionally) joins them using
#' `bind_rows`, `left_join`, or `full_join`.
#'
#' @param folder Path to the folder to search.
#' @param keywords Character vector of filename keywords to match.
#' @param join_method Join strategy: one of `"bind_rows"` (default),
#'   `"left_join"`, or `"full_join"`.
#' @param by Character vector of join keys (required when `join_method` is not
#'   `"bind_rows"`).
#' @param recursive Logical; search subdirectories? Default `TRUE`.
#' @param ignore_case Logical; case-insensitive filename matching? Default `TRUE`.
#' @param full_names Logical; return full file paths? Default `TRUE`.
#' @param require_approval_on_diff Logical; when `TRUE`, if column name/order
#'   mismatches are found you’re prompted to proceed. Default `TRUE`.
#' @param force Logical; skip the prompt and proceed even when differences are
#'   detected. Default `FALSE`.
#' @param encoding Optional file encoding passed to `readr::locale()`
#'   (e.g., `"UTF-8"`, `"latin1"`). Default `"UTF-8"`.
#' @param id_col Optional; when using `bind_rows`, add a column with the source
#'   filename. Set to `NULL` to omit.
#' @param show_compare_details Logical; print per-file column comparisons.
#'   Default `TRUE`.
#' @param also_run_compare_function Logical; if `TRUE` and a function named
#'   `compare_variable_names()` exists, it will be called for each file pair.
#'
#' @return A data frame produced by joining the selected files (or `NULL` if
#'   discrepancies were found and approval was denied). When `bind_rows` is used
#'   with `id_col`, the result includes that source column.
#'
#' @details
#' **Standardization of ID codes (idempotent; runs only on columns that exist):**
#' - `county_code` → 2 chars, left-padded with `0` (non-digits removed first).
#' - `district_code` → 5 chars, left-padded with `0`.
#' - `school_code` → 7 chars, left-padded with `0`.
#' - `cds` → 14 chars; if missing or not 14 digits, it is rebuilt as
#'   `paste0(county_code, district_code, school_code)` when those parts exist,
#'   then left-padded to 14.
#'
#' Additional behaviors:
#' - Forces the ID columns above to **character** type on read when present.
#' - Normalizes all character columns to UTF-8 via `iconv`.
#' - Compares column names (and order) across files and reports differences.
#' - If `require_approval_on_diff = TRUE` (default) and differences are found,
#'   the function prompts before continuing (unless `force = TRUE`).
#'
#' @examples
#' \dontrun{
#' # Simple row-bind with source column
#' out <- load_and_compare_files(
#'   folder = "T:/Data Warehouse/Assessment/dim",
#'   keywords = "school",
#'   join_method = "bind_rows",
#'   id_col = "source_file"
#' )
#'
#' # Full join on keys after schema check
#' out2 <- load_and_compare_files(
#'   folder = "path/to/folder",
#'   keywords = c("part1", "part2"),
#'   join_method = "full_join",
#'   by = c("cds", "year"),
#'   force = TRUE
#' )
#' }
#'
#' @importFrom readr read_csv cols col_guess col_character locale
#' @importFrom dplyr bind_rows mutate across where
#' @importFrom stringr str_pad
#' @export

load_and_compare_files <- function(
    folder,
    keywords,
    join_method = c("bind_rows", "left_join", "full_join"),
    by = NULL,
    recursive = TRUE,
    ignore_case = TRUE,
    full_names = TRUE,
    require_approval_on_diff = TRUE,
    force = FALSE,
    encoding = NULL,
    id_col = "source_file",
    show_compare_details = TRUE,
    also_run_compare_function = FALSE) {

  library(dplyr); library(stringr)

  `%||%` <- function(x, y) if (is.null(x) || (length(x) == 1 && is.na(x))) y else x

  join_method <- match.arg(join_method)

  # NEW: idempotent code normalizer
  standardize_codes <- function(df) {
    to_chr <- function(x) as.character(x)

    if ("county_code"   %in% names(df)) df$county_code   <- str_pad(gsub("\\D","", to_chr(df$county_code)),   2, pad = "0")
    if ("district_code" %in% names(df)) df$district_code <- str_pad(gsub("\\D","", to_chr(df$district_code)), 5, pad = "0")
    if ("school_code"   %in% names(df)) df$school_code   <- str_pad(gsub("\\D","", to_chr(df$school_code)),   7, pad = "0")

    if ("cds" %in% names(df)) {
      cds <- gsub("\\D","", to_chr(df$cds))
      good <- nchar(cds) == 14
      if (all(c("county_code","district_code","school_code") %in% names(df))) {
        cds[!good] <- paste0(df$county_code, df$district_code, df$school_code)[!good]
      }
      df$cds <- str_pad(cds, 14, pad = "0")
    } else if (all(c("county_code","district_code","school_code") %in% names(df))) {
      df$cds <- paste0(df$county_code, df$district_code, df$school_code)
    }

    df
  }

  selected_files <- files_by_keywords(
    folder = folder,
    keywords = keywords,
    recursive = recursive,
    ignore_case = ignore_case,
    full_names = full_names
  )
  if (length(selected_files) == 0) {
    message("🔍 No files matched the keywords: ", paste(keywords, collapse = ", "))
    return(invisible(NULL))
  }
  if (join_method == "left_join" && length(selected_files) < 2) {
    stop("❌ Need at least two files for left_join.")
  }
  if (join_method == "full_join" && length(selected_files) < 2) {
    stop("❌ Need at least two files for full_join.")
  }

  # ---- read all dfs (force key code columns to character) ----
  dfs <- lapply(
    selected_files,
    function(p) {

      loc <- readr::locale(encoding = encoding %||% "UTF-8")
      force_char_cols <- c("cds","county_code","district_code","school_code")

      # Peek header to know which forced columns are present (case-insensitive)
      hdr <- readr::read_csv(p, n_max = 0, show_col_types = FALSE, locale = loc)

      hdr_names <- names(hdr)

      hdr_names_clean <- trimws(hdr_names)

      present_idx <- which(tolower(hdr_names_clean) %in% force_char_cols)

      present_names <- hdr_names[present_idx]

      if (length(present_names)) {
        # Build a col_types spec: guess everything, override these to character
        spec <- readr::cols(.default = readr::col_guess())
        for (nm in present_names) spec$cols[[nm]] <- readr::col_character()
        df <- readr::read_csv(p, show_col_types = FALSE, locale = loc, col_types = spec)
      } else {
        df <- readr::read_csv(p, show_col_types = FALSE, locale = loc)
      }

      # Normalize all character data to UTF-8 (as you were doing)
      if (ncol(df)) {
        df <- dplyr::mutate(df, dplyr::across(where(is.character), ~ iconv(.x, from = "", to = "UTF-8")))
      }

      # NEW: force/pad codes & rebuild cds when possible
      # functionally like pad_cds_codes

      df <- standardize_codes(df)

      df
    }
  )

  names(dfs) <- basename(selected_files)

  ref_name <- names(dfs)[1]
  ref_df   <- dfs[[1]]
  has_discrepancies <- FALSE

  if (length(dfs) >= 2) {
    for (i in 2:length(dfs)) {
      compare_name <- names(dfs)[i]
      compare_df   <- dfs[[i]]

      cols_ref <- names(ref_df)
      cols_cmp <- names(compare_df)

      only_in_ref <- setdiff(cols_ref, cols_cmp)
      only_in_cmp <- setdiff(cols_cmp, cols_ref)

      same_names <- setequal(cols_ref, cols_cmp)
      same_order <- identical(cols_ref, cols_cmp)

      if (show_compare_details) {
        cat("\n=============================================================\n")
        cat("📋 Comparing ", ref_name, "  vs  ", compare_name, "\n", sep = "")
        cat("-------------------------------------------------------------\n")

        if (length(only_in_ref)) {
          cat("In ", ref_name, " but not in ", compare_name, ":\n  - ",
              paste(only_in_ref, collapse = "\n  - "), "\n", sep = "")
        } else {
          cat("No variables in ", ref_name, " that are missing from ", compare_name, "\n", sep = "")
        }

        if (length(only_in_cmp)) {
          cat("\nIn ", compare_name, " but not in ", ref_name, ":\n  - ",
              paste(only_in_cmp, collapse = "\n  - "), "\n", sep = "")
        } else {
          cat("\nNo variables in ", compare_name, " that are missing from ", ref_name, "\n", sep = "")
        }

        if (same_names && !same_order) {
          cat("\n⚠️ Column names are identical but appear in a different order.\n")
        }

        cat("=============================================================\n")
      }

      if (!same_names) {
        has_discrepancies <- TRUE
      } else if (!same_order) {
        has_discrepancies <- TRUE
        message("⚠️ Column names are the same, but order differs between ", ref_name, " and ", compare_name)
      }

      if (also_run_compare_function && exists("compare_variable_names", mode = "function")) {
        tmp <- new.env(parent = .GlobalEnv)
        ref_sym <- as.name(make.names(ref_name))
        cmp_sym <- as.name(make.names(compare_name))
        assign(as.character(ref_sym), ref_df,     envir = tmp)
        assign(as.character(cmp_sym), compare_df, envir = tmp)
        eval(call("compare_variable_names", ref_sym, cmp_sym), envir = tmp)
      }
    }
  }

  if (has_discrepancies && require_approval_on_diff && !force) {
    if (!interactive()) {
      message("\n⚠️ Differences detected. Aborting join in non-interactive session.")
      return(invisible(NULL))
    }
    resp <- readline("❗ Differences detected (name or order). Proceed with join anyway? (yes/no): ")
    if (tolower(trimws(resp)) != "yes") {
      message("\n⚠️ Please resolve column differences before joining.")
      return(invisible(NULL))
    }
  }

  if (join_method == "bind_rows") {
    if (is.null(id_col)) {
      return(dplyr::bind_rows(dfs))
    } else {
      return(dplyr::bind_rows(dfs, .id = id_col))
    }
  } else {
    if (is.null(by)) stop("❌ For left_join, you must supply `by` with join key(s).")
    out <- dfs[[1]]
    for (i in 2:length(dfs)) {
      out <- switch(
        join_method,
        left_join = dplyr::left_join(out, dfs[[i]], by = by),
        full_join = dplyr::full_join(out, dfs[[i]], by = by),
        stop("❌ Unsupported join_method: ", join_method)
      )
    }

    return(out)
  }
}
